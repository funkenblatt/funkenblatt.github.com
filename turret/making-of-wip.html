<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><title>Purely Functional Browser Games</title><style type="text/css">body { font-family: sans-serif; font-size: 0.9em }div.container {width: 60%; margin-left: auto; margin-right: auto; }
img { border: 1px solid #000; }
.font-lock-string-face { color: #8b2252; }
.clojure-interop-method-face { color: #483d8b; }
.font-lock-constant-face { color: #008b8b; }
.font-lock-function-name-face { color: #0000ff; }
.font-lock-variable-name-face { color: #a0522d; }
.clojure-keyword-face { color: #008b8b; }
.font-lock-type-face { color: #228b22; }
.font-lock-keyword-face { color: #a020f0; }
.default { color: #000000; background: #ffffff; font-weight: normal; }
</style></head><body><div class="container"><h1>Purely Functional Browser Games</h1><p>I made <a href="/turret/">this game</a> a while back. This article is a rough
summary of how I did it.</p><h2>Preliminaries</h2><p>This article assumes some basic familiarity with Clojure, leiningen, Clojurescript, and the
browser programming environment, i.e. what the DOM is and whatnot.  It also assumes
high school math knowledge, though I won't be going into too much detail into the
math bits.  Finally, this article is mostly aimed at people who are somewhat familiar
with clojure, but aren't quite sure how one would structure a game using purely
functional data structures.</p><p><a href="https://github.com/funkenblatt/figwheel-test/blob/master/cljs/figwheel_test/turret.cljs">This</a>
is where you can find the main source of the final game.  I won't be covering the development
of the entire game, just covering the basic principles that guided it.  If you'd like to follow along,
you can clone the <b>figwheel-test</b> parent repository.
I'd also highly suggest figuring out how to get 
<a href="https://github.com/bhauman/lein-figwheel">figwheel</a> and a clojurescript
browser REPL working within your development environment of choice.</p><p>If you are following along, you'll want to start off in a namespace such as the
following:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">ns</span><span class="default"> </span><span class="font-lock-type-face">figwheel-test.turret-walkthrough</span><span class="default">
  (</span><span class="clojure-keyword-face">:require</span><span class="default"> [</span><span class="font-lock-type-face">figwheel-test.common</span><span class="default">
             </span><span class="clojure-keyword-face">:refer</span><span class="default"> [tau canvas ctx fooprint init-elements scale-factor
                     with-viewport on-space]
             </span><span class="clojure-keyword-face">:as</span><span class="default"> com]
            [</span><span class="font-lock-type-face">figwheel-test.geometry</span><span class="default"> </span><span class="clojure-keyword-face">:as</span><span class="default"> g]
            [</span><span class="font-lock-type-face">figwheel-test.canvas</span><span class="default"> </span><span class="clojure-keyword-face">:as</span><span class="default"> c])
  (</span><span class="clojure-keyword-face">:require-macros</span><span class="default"> [</span><span class="font-lock-type-face">figwheel-test.macros</span><span class="default"> </span><span class="clojure-keyword-face">:as</span><span class="default"> m]))</span></pre>
</blockquote><h2>Blank Slate</h2><p>OK so let's say you've got figwheel up and running, and you're now connected to
http://localhost:3449/ and staring at a blank screen.  Terrifying, huh?  Let's
fill that soul-devouring void with something more comfortable.</p><p>The code for doing this is in the
<a href="https://github.com/funkenblatt/figwheel-test/blob/master/cljs/figwheel_test/turret.cljs">figwheel-test.common</a>
namespace, which is where I put
all the miscellaneous common code that I use across all my games.
I use a library called <a href="https://github.com/jeluard/hipo">Hipo</a> to make my
DOM elements, though I probably didn't really need it.  It basically uses macros to
translate <a href="https://github.com/weavejester/hiccup/">hiccup</a> syntax into DOM
elements, which can then be stuck into variables like I've done here.</p><p>Anyway the main thing we care about here is calling the function</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-type-face">com</span><span class="default">/init-elements)</span></pre>
</blockquote><p>from our REPL, which will give us a canvas with a border around it.</p><h2>Questions</h2><p>What is a game, anyway?  Well, the fundamental structure of every game is pretty simple.
You have some sort of piece of information that describes the game world, or "state."
Then you have a function that creates and returns a new world, based on a combination
of whatever the current world is and any user inputs.  This basic model of a game works
for everything from tic-tac-toe to DOOM and beyond.</p><blockquote>Game = (World, UserInputs) -> World</blockquote><p>That's it!  Sounds easy, right?  Well, I lied, there's actually a bit more to it.  One thing
is when we actually need to update the state.  This will depend on what sort of game you're
making.  For a tic-tac-toe game, for example, you'll only need to update the game state when
a user actually clicks on something.  For a game like the one we'll be making here, though,
the game world will have to get updated all the time, even if the player isn't necessarily
doing anything (you could think of this as counting the passage of time as a user input).</p><p>Another thing is, in order for most people to make sense out of the world state, we're going
to need to visualize it for them instead of just showing them the raw data.  So we need some
sort of function that takes a world state and draws it.</p><p>All that said, this is Clojure, damnit, so we're going to worry about the important part first:
data.  Which is what our world will be composed of.</p><h2>I Threw It On The Ground</h2><p>Making an entire world sounds like a lot of work, and it is.  Fortunately we don't have to do
it all at once, we can just incrementally add bits and pieces to the world as we see fit.  When
I made this game I decided to start with the ground.</p><p>The ground, in our case, is just a list of x-y coordinates.  For the purposes of my game, I'm
assuming there's no weird things like gaps in our terrain, or extra terrain in the sky, or
whatever.  The way we're actually going to think of the terrain is as a list of points, with
line segments connecting them.  So our world right now might look something like this:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">init-state</span><span class="default"> {</span><span class="clojure-keyword-face">:terrain</span><span class="default"> [[-640 -300] [-320 -215] [0 -215] [320 -215] [640 -300]]})</span></pre>
</blockquote><p>Now you'll notice that I've chosen -640 and 640 as my x-coordinates for the first and last
points, respectively.  That's because I've decided that the boundaries of the game world
are going to look something like this:<br/>
<img src="coordinates.svg" width="500"/></p><p>As far as our game is concerned, anything that leaves these boundaries is dead to us.  We'll
be enforcing that later once we deal with the parts of the game that actually move.</p><p>Note that these are game-world coordinates, not screen coordinates.  We actually aren't really
going to care much about screen coordinates at all in this article, other than to note that
they're not the same thing.</p><h2>Different Strokes</h2><p>So, now we have the first part of our world ready.  Normally we'd say the next step is to
write some sort of update function, but as it turns out the ground isn't really going to
change much (for now).  So instead we're going to skip that and just go straight to drawing
this part of our world.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">draw-state</span><span class="default"> [state]
  (with-viewport
    #(apply </span><span class="font-lock-type-face">c</span><span class="default">/stroke-lines ctx (</span><span class="clojure-keyword-face">:terrain</span><span class="default"> state))
    </span><span class="font-lock-constant-face">true</span><span class="default">))</span></pre>
</blockquote><p>Here we've introduced some new utility functions.  First, <b>with-viewport</b>
basically does all the work of transforming the HTML5 canvas coordinate system into one compatible
with the game coordinate system, and then calls a passed-in function which will do the whatever drawing
operations need to be done.  Once that function is done, it then restores the canvas coordinate
system to its original state, which can be useful if you want to do other stuff in the "normal"
coordinate system (we don't, in this game, but whatever).  <b>with-viewport</b> also takes a "clear"
argument that erases the canvas before drawing if true, which is what we happen to want right now.</p><p>Next we have <b>c/stroke-lines</b>,  which pretty much just takes a bunch of points and draws lines
between them.  That function is part of the
<a href="https://github.com/funkenblatt/figwheel-test/blob/master/cljs/figwheel_test/canvas.cljs">figwheel-test.canvas</a>
namespace, which is where I put most of my general drawing-related functions.</p><p>Now we can see what our world looks like:</p><blockquote><pre>
<span class="default">(draw-state init-state)</span></pre>
</blockquote><p><img src="terrain-1.png" width="600"></p><h2>Just Turret Things</h2><p>As of now we don't actually have anything we can control yet.  We just have land.
Pretty boring.  Let's add some player state to the mix.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">init-state</span><span class="default"> {</span><span class="clojure-keyword-face">:terrain</span><span class="default"> [[-640 -300] [-320 -215] [0 -215] [320 -215] [640 -300]]
                 </span><span class="clojure-keyword-face">:player</span><span class="default"> {</span><span class="clojure-keyword-face">:th</span><span class="default"> 0 </span><span class="clojure-keyword-face">:pos</span><span class="default"> [0 -200]}})</span></pre>
</blockquote><p>This contains the bare minimum for what we would want out of a turret: an angle <b>th</b>
(short for theta or θ) which represents where the turret is aiming, and a position <b>pos</b>
which just represents where the turret is sitting.</p><p>What would an update function for this turret look like?  Maybe something like this:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">turret-update</span><span class="default"> [{</span><span class="clojure-keyword-face">:keys</span><span class="default"> [th pos] </span><span class="clojure-keyword-face">:as</span><span class="default"> self} pointer]
  (</span><span class="font-lock-keyword-face">let</span><span class="default"> [dir (</span><span class="font-lock-type-face">g</span><span class="default">/v- pointer pos)]
    (assoc self </span><span class="clojure-keyword-face">:th</span><span class="default"> (</span><span class="font-lock-type-face">g</span><span class="default">/vec-angle dir))))</span></pre>
</blockquote><p>The pointer argument, in this case, would be the current mouse location, translated
into world coordinates.  All this state function does is update the turret's
angle based on where the cursor is.  This is a perfectly reasonable place to start,
but it's kind of boring.  Let's make things hard for the player by giving the turret
some mass, so it takes a non-zero amount of time to swivel to the aiming point.</p><p>Side note: the g namespace here refers to the 
<a href="https://github.com/funkenblatt/figwheel-test/blob/master/cljs/figwheel_test/geometry.cljs">figwheel-test.geometry</a>
namespace, which is where I put all of my common geometry-related functions.  <b>v-</b> subtracts
one vector from another, and <b>vec-angle</b> returns the angle that a particular vector makes
with the x-axis.</p><p>In order to make this happen, we'll have to add some stuff to the turret state.  Because
the turret will no longer be instantly following the pointer, we'll need to add an
angular velocity, which will determine how far to move each frame.  Then we'll need
to somehow update this angular velocity based on user input.</p><p>We'll call this angular velocity <b>w</b> (easier to type than ω).  We'll also introduce
two other terms, <b>b</b> and <b>k</b>, which I'll explain in a bit.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">init-state</span><span class="default"> {</span><span class="clojure-keyword-face">:terrain</span><span class="default"> [[-640 -300] [-320 -215] [0 -215] [320 -215] [640 -300]]
                 </span><span class="clojure-keyword-face">:player</span><span class="default"> {</span><span class="clojure-keyword-face">:th</span><span class="default"> 0 </span><span class="clojure-keyword-face">:w</span><span class="default"> 0 </span><span class="clojure-keyword-face">:pos</span><span class="default"> [0 -200] </span><span class="clojure-keyword-face">:k</span><span class="default"> 0.02 </span><span class="clojure-keyword-face">:b</span><span class="default"> 0.15}})</span></pre>
</blockquote><p>And of course, we'll have to modify the update function:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">turret-update</span><span class="default"> [{</span><span class="clojure-keyword-face">:keys</span><span class="default"> [th pos w k b] </span><span class="clojure-keyword-face">:as</span><span class="default"> self} pointer]
  (</span><span class="font-lock-keyword-face">let</span><span class="default"> [dir (</span><span class="font-lock-type-face">g</span><span class="default">/v- pointer pos)
        er [(</span><span class="font-lock-type-face">js</span><span class="default">/Math.cos th) (</span><span class="font-lock-type-face">js</span><span class="default">/Math.sin th)]
        delta (</span><span class="font-lock-type-face">js</span><span class="default">/Math.atan2 (</span><span class="font-lock-type-face">g</span><span class="default">/vcross er dir) (</span><span class="font-lock-type-face">g</span><span class="default">/vdot er dir))
        new-w (+ w (* k delta) (* -1 w b))
        new-th (+ th w)]
    (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> (assoc self </span><span class="clojure-keyword-face">:th</span><span class="default"> (</span><span class="font-lock-type-face">com</span><span class="default">/clamp 0 new-th (/ tau 2)))
        (assoc </span><span class="clojure-keyword-face">:w</span><span class="default"> (</span><span class="font-lock-keyword-face">if</span><span class="default"> (</span><span class="font-lock-keyword-face">or</span><span class="default"> (&lt; new-th 0) (&gt; new-th (/ tau 2)))
                    0 new-w)))))</span></pre>
</blockquote><p>Huh, what's going on here?  Well, what I've done here is to model the turret's angular
velocity as being updated using
<a href="https://en.wikipedia.org/wiki/PID_controller">feedback control</a>.  I won't
go into too much detail about the math here, but basically, <b>k</b> controls how quickly
the turret will snap into place, and <b>b</b> will suppress the "overshoot" that will inevitably
occur otherwise.  <b>k</b> and <b>b</b> don't technically have to be part of the turret state,
as they never really change.  However, in future iterations of the game, they could
be made to change via a powerup or perhaps when damage has been taken.</p><p>Another area of note is the <b>delta</b> variable, which computes the difference between
the desired angle of aim (i.e. whatever <b>th</b> should be in order to point at <b>pointer</b>)
and the actual point of aim.  Some vector math knowledge is needed to make sense of that,
for which I defer to 
wikipedia<a href="http://en.wikipedia.org/wiki/Dot_product">[1]</a><a href="http://en.wikipedia.org/wiki/Cross_product">[2]</a>.</p><p>Finally, note that I clamp the new value of <b>th</b> to within a certain range, because the
turret has a finite range of travel.  I also force <b>w</b> to 0 if <b>th</b> is about to leave
that range.</p><p>OK, so now we have some sort of update function for the turret.  But what does this thing
even look like?</p><p>Well, I could draw something fancy, or I could just stick some circles and lines
together.  Let's just stick with the second option.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">turret-draw</span><span class="default"> [{</span><span class="clojure-keyword-face">:keys</span><span class="default"> [th pos]} ctx]
  (</span><span class="font-lock-type-face">c</span><span class="default">/with-saved-context
    ctx
    (</span><span class="font-lock-keyword-face">fn</span><span class="default"> []
      (</span><span class="font-lock-keyword-face">let</span><span class="default"> [[x y] pos]
        (</span><span class="clojure-interop-method-face">.translate</span><span class="default"> ctx x y)
        (</span><span class="font-lock-type-face">c</span><span class="default">/with-saved-context
          ctx
          (</span><span class="font-lock-keyword-face">fn</span><span class="default"> []
            (</span><span class="clojure-interop-method-face">.rotate</span><span class="default"> ctx th)
            (</span><span class="font-lock-type-face">c</span><span class="default">/stroke-lines ctx [20 -3] [20 3] [40 3] [40 -3] [20 -3])))
        (</span><span class="font-lock-keyword-face">set!</span><span class="default"> (</span><span class="clojure-interop-method-face">.-fillStyle</span><span class="default"> ctx) </span><span class="font-lock-string-face">&quot;#fff&quot;</span><span class="default">)
        (</span><span class="clojure-interop-method-face">.beginPath</span><span class="default"> ctx)
        (</span><span class="clojure-interop-method-face">.arc</span><span class="default"> ctx 0 0 30 (/ tau -12) (/ (* 7 tau) 12))
        (</span><span class="clojure-interop-method-face">.lineTo</span><span class="default"> ctx (* 15 (</span><span class="font-lock-type-face">js</span><span class="default">/Math.sqrt 3)) -15)
        (</span><span class="clojure-interop-method-face">.fill</span><span class="default"> ctx)
        (</span><span class="clojure-interop-method-face">.stroke</span><span class="default"> ctx)))))</span></pre>
</blockquote><p>The use of HTML5 Canvas operations is a bit out of the scope of this article, so I'll
just direct you to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial">MDN Canvas Tutorial</a>.</p><p>Of course, now we'll have to update our whole-world drawing function, <b>draw-state</b>:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">draw-state</span><span class="default"> [state]
  (</span><span class="font-lock-type-face">com</span><span class="default">/with-viewport
    #(</span><span class="font-lock-keyword-face">do</span><span class="default"> (apply </span><span class="font-lock-type-face">c</span><span class="default">/stroke-lines </span><span class="font-lock-type-face">com</span><span class="default">/ctx (</span><span class="clojure-keyword-face">:terrain</span><span class="default"> state))
         (turret-draw (</span><span class="clojure-keyword-face">:player</span><span class="default"> state) </span><span class="font-lock-type-face">com</span><span class="default">/ctx))
    </span><span class="font-lock-constant-face">true</span><span class="default">))</span></pre>
</blockquote><p>Here's what <b>(draw-state init-state)</b> should look like now:<br/>
<img src="terrain-turret.png" width="600"/></p><h2>Putting It All Together</h2><p>It's about time that we get to see some of this state-updating in action.  The way we'll
do this is pretty simple, it's conceptually just a continuously updating loop.  First we'll
set up some preliminary bits:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">stop</span><span class="default"> (atom </span><span class="font-lock-constant-face">false</span><span class="default">))
(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">state</span><span class="default"> (atom init-state))
(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">pointer</span><span class="default"> (atom [1 0]))
(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">screen-&gt;world</span><span class="default"> [p]
  (</span><span class="font-lock-keyword-face">let</span><span class="default"> [[x y] (</span><span class="font-lock-type-face">g</span><span class="default">/v- (</span><span class="font-lock-type-face">g</span><span class="default">/vscale (/ 1 (scale-factor)) p) [640 480])]
    [x (- y)]))
(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">update-state</span><span class="default"> [state pointer]
  (update state </span><span class="clojure-keyword-face">:player</span><span class="default"> turret-update pointer))</span></pre>
</blockquote><p><b>stop</b> is going to be used for when we want to stop the game loop.  <b>state</b> is where we'll
be storing the current game state.  <b>pointer</b> will hold the current location of the mouse
pointer.  <b>screen->world</b> is a utility function that will be used to convert canvas pixel
coordinates, which is what we'll be getting from the javascript mouse movement API, into 
game world coordinates.  Finally, <b>update-state</b> is the "toplevel" state
updating function that will be used to handle the entire game world update, of which the
turret is just a part of.</p><p>Here's the function that will actually set the game loop running:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">run-loop</span><span class="default"> []
  (reset! stop </span><span class="font-lock-constant-face">false</span><span class="default">)
  (</span><span class="font-lock-keyword-face">set!</span><span class="default"> </span><span class="font-lock-type-face">js</span><span class="default">/window.onmousemove
        (</span><span class="font-lock-keyword-face">fn</span><span class="default"> [evt]
          (reset! pointer (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> [(</span><span class="clojure-interop-method-face">.-pageX</span><span class="default"> evt) (</span><span class="clojure-interop-method-face">.-pageY</span><span class="default"> evt)]
                          (</span><span class="font-lock-type-face">g</span><span class="default">/v- (</span><span class="font-lock-type-face">c</span><span class="default">/elem-offset canvas))
                          screen-&gt;world))))
  ((</span><span class="font-lock-keyword-face">fn</span><span class="default"> lp []
      (</span><span class="font-lock-keyword-face">when</span><span class="default"> (not @stop)
        (draw-state @state)
        (swap! state update-state @pointer)
        (</span><span class="font-lock-type-face">js</span><span class="default">/window.requestAnimationFrame lp)))))</span></pre>
</blockquote><p>The first part of the function just makes sure that <b>stop</b> is false, and sets up the javascript
event handler needed to keep <b>pointer</b> up to date.  For the actual "loop", we use a named fn which
just checks to see if we should stop, draws the current state, updates the current state using <b>update-state</b>,
and then <b>reschedules itself</b> to run again, using <b>js/window.requestAnimationFrame</b>.
Finally we call the <b>lp</b> fn within <b>run-loop</b> in order to actually start the updating process.</p><p>Note that there's no really good reason for doing the actual loop within a nested function as opposed
breaking it out into its own function.  This is just how I decided to do it.</p><p>Take a moment to play with the turret aiming.  When you're done, you can execute</p><blockquote><pre>
<span class="default">(reset! stop </span><span class="font-lock-constant-face">true</span><span class="default">)</span></pre>
</blockquote><p>to pause things and let your computer relax for a bit.</p><h2>Bullets!  My Only Weakness</h2><p>We have a turret now, but of course a turret that doesn't shoot any bullets isn't very
useful.  So let's add some bullets.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">init-state</span><span class="default"> {</span><span class="clojure-keyword-face">:terrain</span><span class="default"> [[-640 -300] [-320 -215] [0 -215] [320 -215] [640 -300]]
                 </span><span class="clojure-keyword-face">:player</span><span class="default"> {</span><span class="clojure-keyword-face">:th</span><span class="default"> 0 </span><span class="clojure-keyword-face">:w</span><span class="default"> 0 </span><span class="clojure-keyword-face">:pos</span><span class="default"> [0 -200] </span><span class="clojure-keyword-face">:k</span><span class="default"> 0.02 </span><span class="clojure-keyword-face">:b</span><span class="default"> 0.15}
                 </span><span class="clojure-keyword-face">:bullets</span><span class="default"> {}})</span></pre>
</blockquote><p>We've added a new key to the game world - <b>:bullets</b>.  I decided to store the set of all active
bullets within the game world using a map, so I've set it to an empty map in <b>init-state</b>.</p><p>What exactly is that map going to map between?  Well for my particular game I decided to assign
each bullet a unique ID, which is used for all operations that need to reference a particular
bullet.  So <b>:bullets</b> maps between bullet IDs and an individual bullet's state.</p><p>An individual bullet only really needs to pieces of information - a position and a velocity.
Here I've referred to them using the keys :x and :v.
Let's take a first crack at what an update function for an individual bullet would look like.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">gravity</span><span class="default"> [0 -0.1])
(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">bullet-update</span><span class="default"> [state name {</span><span class="clojure-keyword-face">:keys</span><span class="default"> [x v] </span><span class="clojure-keyword-face">:as</span><span class="default"> self}]
  (assoc-in state [</span><span class="clojure-keyword-face">:bullets</span><span class="default"> name]
            (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> self
                (update </span><span class="clojure-keyword-face">:v</span><span class="default"> </span><span class="font-lock-type-face">g</span><span class="default">/v+ gravity)
                (update </span><span class="clojure-keyword-face">:x</span><span class="default"> </span><span class="font-lock-type-face">g</span><span class="default">/v+ v))))</span></pre>
</blockquote><p>Why does this function take the entire game state as its first argument, and then
an ID and a single bullet state as other arguments?  Well as it turns out we'll need
the entire state in order to do certain operations on an individual bullet, such as
checking for collisions with terrain or other targets.  Also, it turns out that there's
a really convenient clojure library function that will make updating every bullet
in the game world simple.</p><p>Anyway, aside from the particularities of its arguments, all this function does is add
gravity to a bullet's current velocity, and also updates the position using the bullet's
current velocity.</p><p>This is a decent start, except for the fact that this bullet basically sticks around forever.
There's plenty of good reasons for a bullet to stop existing, like if it leaves the screen,
or if it hits the ground, or hits some other target.  Right now we don't actually have other
targets, though, and checking for hitting the ground is a bit more complicated, so let's
just handle the simplest case - checking if the bullet has left our declared world boundaries.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">bullet-update</span><span class="default"> [state name {</span><span class="clojure-keyword-face">:keys</span><span class="default"> [x v] </span><span class="clojure-keyword-face">:as</span><span class="default"> self}]
  (</span><span class="font-lock-keyword-face">if</span><span class="default"> (</span><span class="font-lock-keyword-face">let</span><span class="default"> [pos x [x y] pos]
        (</span><span class="font-lock-keyword-face">or</span><span class="default"> (&gt; (</span><span class="font-lock-type-face">js</span><span class="default">/Math.abs x) 640)
            (&gt; (</span><span class="font-lock-type-face">js</span><span class="default">/Math.abs y) 480)))
    (update state </span><span class="clojure-keyword-face">:bullets</span><span class="default"> dissoc name)
    (assoc-in state [</span><span class="clojure-keyword-face">:bullets</span><span class="default"> name]
              (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> self
                  (update </span><span class="clojure-keyword-face">:v</span><span class="default"> </span><span class="font-lock-type-face">g</span><span class="default">/v+ gravity)
                  (update </span><span class="clojure-keyword-face">:x</span><span class="default"> </span><span class="font-lock-type-face">g</span><span class="default">/v+ v)))))</span></pre>
</blockquote><p>We could add the terrain check while we're at it, but if you're impatient like me,
you really just want to start seeing some bullets fly around.  We'll have to draw
the bullets, of course:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">bullet-draw</span><span class="default"> [{</span><span class="clojure-keyword-face">:keys</span><span class="default"> [x v]} ctx]
  (</span><span class="font-lock-type-face">c</span><span class="default">/stroke-lines ctx x (</span><span class="font-lock-type-face">g</span><span class="default">/v- x v)))</span></pre>
</blockquote><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">draw-state</span><span class="default"> [state]
  (</span><span class="font-lock-type-face">com</span><span class="default">/with-viewport
    #(</span><span class="font-lock-keyword-face">do</span><span class="default"> (apply </span><span class="font-lock-type-face">c</span><span class="default">/stroke-lines </span><span class="font-lock-type-face">com</span><span class="default">/ctx (</span><span class="clojure-keyword-face">:terrain</span><span class="default"> state))
         (turret-draw (</span><span class="clojure-keyword-face">:player</span><span class="default"> state) </span><span class="font-lock-type-face">com</span><span class="default">/ctx)
         (run! (</span><span class="font-lock-keyword-face">fn</span><span class="default"> [[n x]] (bullet-draw x ctx))
               (</span><span class="clojure-keyword-face">:bullets</span><span class="default"> state)))
    </span><span class="font-lock-constant-face">true</span><span class="default">))</span></pre>
</blockquote><h2>Update ALL The THINGS</h2><p>So we now have a place in our game state to hold all of our bullets, and we have
a function that will do the update needed for a single bullet.  Now we just need
to iterate over every bullet and update it.</p><p>There's a bunch of ways to write this accumulation in clojure.  The way I chose to do it,
however, uses a handy function from the clojure standard library called <b>reduce-kv</b>.
The primary advantage of using <b>reduce-kv</b> over any other reduce-like thingamabobber
is that, when called on a map, <b>reduce-kv</b> will do a loop over said map
without creating any intermediate sequence, as opposed to just plain
<b>reduce</b>, which will convert the map to a lazy sequence first.  It's
a small performance benefit, but it's not one that's particularly difficult
to take advantage of.</p><p>As it turns out the arguments I've made <b>bullet-update</b> take are already
perfect for use with <b>reduce-kv</b>.  All we have to do is pass it in as our
reducing function, and then incorporate it into our top-level state
update function:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">update-state</span><span class="default"> [state pointer]
  (reduce-kv bullet-update
             (update state </span><span class="clojure-keyword-face">:player</span><span class="default"> turret-update pointer)
             (</span><span class="clojure-keyword-face">:bullets</span><span class="default"> state)))</span></pre>
</blockquote><p>This works fine, but because I happen to know that I'll be doing a bunch
of similar operations on other groups of objects (the enemies
that appear in the completed game, and the particle bits), I use this
simple helper function:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">update-all</span><span class="default"> [state key update-fn]
  (reduce-kv update-fn state (key state)))</span></pre>
</blockquote><p>This helper function has the side benefit of making it possible to use
the thread-first macro (<b>-></b>), which is useful once we start stacking
on other state modifications:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">update-state</span><span class="default"> [state pointer]
  (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> (update state </span><span class="clojure-keyword-face">:player</span><span class="default"> turret-update pointer)
      (update-all </span><span class="clojure-keyword-face">:bullets</span><span class="default"> bullet-update)))</span></pre>
</blockquote><p>Now we can try running the game with the bullet update in place,
using <b>(run-loop)</b> again.  While the game is running, you can try
adding a bullet to the game state:</p><blockquote><pre>
<span class="default">(swap! state update </span><span class="clojure-keyword-face">:bullets</span><span class="default"> assoc 0 {</span><span class="clojure-keyword-face">:x</span><span class="default"> [0 -200] </span><span class="clojure-keyword-face">:v</span><span class="default"> [0 15]})</span></pre>
</blockquote><p>This should send a bullet straight up and off the screen.  Neat, huh?</p><p>Let's wrap this whole "add a bullet to the world" thing into a function:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">gen-id</span><span class="default">
  (</span><span class="font-lock-keyword-face">let</span><span class="default"> [n (atom 0)]
    (</span><span class="font-lock-keyword-face">fn</span><span class="default"> [] (swap! n (</span><span class="font-lock-keyword-face">fn</span><span class="default"> [x] (mod (+ x 1) 100000))))))</span></pre>
</blockquote><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">spawn-bullet</span><span class="default"> [state th pos]
  (</span><span class="font-lock-keyword-face">let</span><span class="default"> [dir (</span><span class="font-lock-type-face">g</span><span class="default">/unit-vector th)]
    (update state </span><span class="clojure-keyword-face">:bullets</span><span class="default"> assoc
            (gen-id)
            {</span><span class="clojure-keyword-face">:x</span><span class="default"> (</span><span class="font-lock-type-face">g</span><span class="default">/v+ pos (</span><span class="font-lock-type-face">g</span><span class="default">/vscale 50 dir))
             </span><span class="clojure-keyword-face">:v</span><span class="default"> (</span><span class="font-lock-type-face">g</span><span class="default">/vscale 15 dir)})))</span></pre>
</blockquote><p>Some quick things to note here: <b>g/unit-vector</b> creates a vector of
length 1 pointed at some given angle.  The <b>(g/v+ pos (g/vscale 50 dir))</b>
term is based on the fact that the turret's gun ends at a
radius 50 away from the center of the turret (which is where <b>pos</b>)
is.  Finally, <b>gen-id</b> is what we use to make new ID's for bullets and
other temporary things.</p><h2>Cooldown</h2><p>So, now that we know how to add a bullet to the world, let's start
using it.  First things first, though, we need to deal with a new
user input - whether the mouse is being held down or not.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">trigger</span><span class="default"> (atom </span><span class="font-lock-constant-face">false</span><span class="default">))</span></pre>
</blockquote><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">run-loop</span><span class="default"> []
  (reset! stop </span><span class="font-lock-constant-face">false</span><span class="default">)
  (</span><span class="font-lock-keyword-face">set!</span><span class="default"> (</span><span class="clojure-interop-method-face">.-onmousedown</span><span class="default"> canvas) (</span><span class="font-lock-keyword-face">fn</span><span class="default"> [] (reset! trigger </span><span class="font-lock-constant-face">true</span><span class="default">) </span><span class="font-lock-constant-face">false</span><span class="default">))
  (</span><span class="font-lock-keyword-face">set!</span><span class="default"> (</span><span class="clojure-interop-method-face">.-onmouseup</span><span class="default"> </span><span class="font-lock-type-face">js</span><span class="default">/window) (</span><span class="font-lock-keyword-face">fn</span><span class="default"> [] (reset! trigger </span><span class="font-lock-constant-face">false</span><span class="default">) </span><span class="font-lock-constant-face">false</span><span class="default">))
  (</span><span class="font-lock-keyword-face">set!</span><span class="default"> </span><span class="font-lock-type-face">js</span><span class="default">/window.onmousemove
        (</span><span class="font-lock-keyword-face">fn</span><span class="default"> [evt]
          (reset! pointer (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> [(</span><span class="clojure-interop-method-face">.-pageX</span><span class="default"> evt) (</span><span class="clojure-interop-method-face">.-pageY</span><span class="default"> evt)]
                          (</span><span class="font-lock-type-face">g</span><span class="default">/v- (</span><span class="font-lock-type-face">c</span><span class="default">/elem-offset canvas))
                          screen-&gt;world))))
  ((</span><span class="font-lock-keyword-face">fn</span><span class="default"> lp []
      (</span><span class="font-lock-keyword-face">when</span><span class="default"> (not @stop)
        (draw-state @state)
        (swap! state update-state @pointer @trigger)
        (</span><span class="font-lock-type-face">js</span><span class="default">/window.requestAnimationFrame lp)))))</span></pre>
</blockquote><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">update-state</span><span class="default"> [state pointer trigger]
  (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> (update state </span><span class="clojure-keyword-face">:player</span><span class="default"> turret-update pointer trigger)
      (update-all </span><span class="clojure-keyword-face">:bullets</span><span class="default"> bullet-update)))</span></pre>
</blockquote><p>You'll notice I've added two lines to the setup code in <b>run-loop</b>.
These basically just keep the <b>trigger</b> variable up to date as to
whether the mouse is currently down or not.  Also notice that
<b>update-state</b> now takes an extra <b>trigger</b> argument, which is
passed on to <b>turret-update</b>.</p><p>Note: at this point, if you currently have the game running, you'll
probably want to stop it (again using <b>(reset! stop true)</b>).</p><p>So.  What is <b>turret-update</b> going to do with that trigger argument?
Well, obviously once the trigger is down it should add a bullet to
the world.  If we do that every frame, though, we'll be spawning
60 bullets per second, which is a lot.  Let's add a <b>cooldown</b>
parameter that will determine whether we can actually shoot yet.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">def</span><span class="default"> </span><span class="font-lock-variable-name-face">init-state</span><span class="default"> {</span><span class="clojure-keyword-face">:terrain</span><span class="default"> [[-640 -300] [-320 -215] [0 -215] [320 -215] [640 -300]]
                 </span><span class="clojure-keyword-face">:player</span><span class="default"> {</span><span class="clojure-keyword-face">:th</span><span class="default"> 0 </span><span class="clojure-keyword-face">:w</span><span class="default"> 0 </span><span class="clojure-keyword-face">:pos</span><span class="default"> [0 -200] </span><span class="clojure-keyword-face">:k</span><span class="default"> 0.02 </span><span class="clojure-keyword-face">:b</span><span class="default"> 0.15 
                          </span><span class="clojure-keyword-face">:cooldown</span><span class="default"> 0}
                 </span><span class="clojure-keyword-face">:bullets</span><span class="default"> {}})</span></pre>
</blockquote><p>In my game, I've defined things such that when <b>:cooldown</b> is equal to 0,
the turret is ready to fire.  If we're firing, which requires cooldown
to be 0 and the trigger to be pulled, we'll set <b>:cooldown</b> to
however many frames we want between shots, and then decrement it
every frame until we get to zero:</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">turret-update</span><span class="default"> [{</span><span class="clojure-keyword-face">:keys</span><span class="default"> [th pos w k b cooldown] </span><span class="clojure-keyword-face">:as</span><span class="default"> self} pointer trigger]
  (</span><span class="font-lock-keyword-face">let</span><span class="default"> [dir (</span><span class="font-lock-type-face">g</span><span class="default">/v- pointer pos)
        er [(</span><span class="font-lock-type-face">js</span><span class="default">/Math.cos th) (</span><span class="font-lock-type-face">js</span><span class="default">/Math.sin th)]
        delta (</span><span class="font-lock-type-face">js</span><span class="default">/Math.atan2 (</span><span class="font-lock-type-face">g</span><span class="default">/vcross er dir) (</span><span class="font-lock-type-face">g</span><span class="default">/vdot er dir))
        new-w (+ w (* k delta) (* -1 w b))
        new-th (+ th w)
        firing (</span><span class="font-lock-keyword-face">and</span><span class="default"> trigger (= cooldown 0))]
    (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> (assoc self </span><span class="clojure-keyword-face">:th</span><span class="default"> (</span><span class="font-lock-type-face">com</span><span class="default">/clamp 0 new-th (/ tau 2)))
        (assoc </span><span class="clojure-keyword-face">:w</span><span class="default"> (</span><span class="font-lock-keyword-face">if</span><span class="default"> (</span><span class="font-lock-keyword-face">or</span><span class="default"> (&lt; new-th 0) (&gt; new-th (/ tau 2)))
                    0 new-w))
        (assoc </span><span class="clojure-keyword-face">:cooldown</span><span class="default"> (</span><span class="font-lock-keyword-face">if</span><span class="default"> firing 5 (max (dec cooldown) 0))))))</span></pre>
</blockquote><p>Dandy!  Except now we have a problem: how do we spawn the actual bullet when
firing?  As it turns out, <b>turret-update</b> is going to need to be able to write
to other parts of the game world, not just itself.</p><blockquote><pre>
<span class="default">(</span><span class="font-lock-keyword-face">defn</span><span class="default"> </span><span class="font-lock-function-name-face">turret-update</span><span class="default"> [state path pointer trigger]
  (</span><span class="font-lock-keyword-face">let</span><span class="default"> [{</span><span class="clojure-keyword-face">:keys</span><span class="default"> [th pos w k b cooldown] </span><span class="clojure-keyword-face">:as</span><span class="default"> self} (get-in state path)
        dir (</span><span class="font-lock-type-face">g</span><span class="default">/v- pointer pos)
        er [(</span><span class="font-lock-type-face">js</span><span class="default">/Math.cos th) (</span><span class="font-lock-type-face">js</span><span class="default">/Math.sin th)]
        delta (</span><span class="font-lock-type-face">js</span><span class="default">/Math.atan2 (</span><span class="font-lock-type-face">g</span><span class="default">/vcross er dir) (</span><span class="font-lock-type-face">g</span><span class="default">/vdot er dir))
        new-w (+ w (* k delta) (* -1 w b))
        new-th (+ th w)
        firing (</span><span class="font-lock-keyword-face">and</span><span class="default"> trigger (= cooldown 0))]
    (assoc-in
     (</span><span class="font-lock-keyword-face">if</span><span class="default"> firing (spawn-bullet state th pos) state)
     path
     (</span><span class="font-lock-keyword-face">-&gt;</span><span class="default"> (assoc self </span><span class="clojure-keyword-face">:th</span><span class="default"> (</span><span class="font-lock-type-face">com</span><span class="default">/clamp 0 new-th (/ tau 2)))
         (assoc </span><span class="clojure-keyword-face">:w</span><span class="default"> (</span><span class="font-lock-keyword-face">if</span><span class="default"> (</span><span class="font-lock-keyword-face">or</span><span class="default"> (&lt; new-th 0) (&gt; new-th (/ tau 2)))
                     0 new-w))
         (assoc </span><span class="clojure-keyword-face">:cooldown</span><span class="default"> (</span><span class="font-lock-keyword-face">if</span><span class="default"> firing 5 (max (dec cooldown) 0)))))))</span></pre>
</blockquote><p>So, now <b>turret-update</b> takes the whole game state as an
argument.  I've also added a new <b>path</b> argument, which tells
<b>turret-update</b> where to find the particular turret that we're
dealing with.  This is just in case we want to have multiple
turrets or something in the future, or maybe if we just want
to be able to rearrange the location of the turret information
within the game state.  <b>path</b> is used as an argument to both
<b>get-in</b> and <b>assoc-in</b>, for reads and writes, respectively.</p><p>Other than the <b>path</b> change, the rest of the function is relatively
unchanged, other than adding the bit that uses <b>spawn-bullet</b>
on the state if we're firing.</p><p>We've added something to the initial state, so in order to keep
things completely safe, we'll probably want to reinitialize the
state atom:</p><blockquote><pre>
<span class="default">(reset! state init-state)</span></pre>
</blockquote><p>Other than that, we should be ready to rip.  Just call
<b>(run-loop)</b> again and fire away.</p><h2>Conclusions</h2><p>This article is pretty damn long-winded already so I'll try and
keep this short.  Hopefully this is enough to get you started on
understanding the rest of the code (other than the math bits, for
which I refer you to 
<a href="https://en.wikipedia.org/wiki/Analytic_geometry">Wikipedia</a>
or something).  If there's sufficient interest I may cover some
other parts of the code in greater detail.</p><p>As for other conclusions, I'd just like to say that
the interactive development environment that clojurescript provides
is friggin' great, and that you shouldn't be afraid of immutability.
All the things you know about manipulating data in clojure still apply
in game-land.</p><p>Happy hacking!
</p></div></body></html>